<html>
<head>
	<script>
		Library.fn = {}; // public methods
		function Library() {

			// Private variables and functions
			var privates = {
				_abc : 5,
				_func : function() {},
				_publics : function() { return publics; },
				_privates : function() { return privates; }
			};

			// Extend publics with what is already set via the outside
			var publics = {
				func1 : function() {},
				chainable : function() { return this._publics(); },
				// Bind .fn function to this specific instance
				register : function(fnName, fn) {
					if (fn) {
						Library.fn[fnName] = fn;
					}
					var func = Library.fn[fnName];
					Library.fn[fnName] = function() { 
						return func.apply(all, arguments);
					};
				}
			};
			publics = extend(publics,Library.fn);
			
			// Create object that contains publics and privates
			var all = extend(privates,publics);
			
			// Set publics+privates object as 'this' for all public functions
			/*
			for(var index in publics) {
				if (publics.hasOwnProperty(index) && typeof publics[index] === "function") {
					publics[index] = publics[index].bind(all);
				}
			}*/
			var proto = publics;
			while(proto) {
				for(var index in proto) {
					if (proto.hasOwnProperty(index) && typeof proto[index] === "function") {
						var func = proto[index];
						proto[index] = function() { 
							return func.apply(all, arguments);
						};
						//proto[index] = proto[index].bind(all);
					}
				}
				proto = Object.getPrototypeOf(proto);
			}

			// Place setter on the Library.fn object, to ensure a proper 'this' within those functions
			Library.fn.__defineSetter__("IDontWantToSpecifyAProperty", function(key,val) {
				console.log("SET!",key,val);
			});
			
			// Helper function to extend Object original with all properties from Object extra
			function extend(original, extra) {
				// - All functions are copied. Hopefully, browsers are efficient in this
				for(var index in extra) {
					original[index] = extra[index];
				}
				/*
				// + Functions are not copied on every instantiation of the library
				// - Any function can only be bound to 1 instance of 'all', which is not what we want
				original.__proto__ = extra;
				*/
				return original;
			}

			// Return facade
			return publics;
		}


		// Accessing privates from external does not work
		var lib = new Library();
		console.log(lib._abc); // undefined
		console.log(lib._func); // undefined
		console.log(lib.func1); // function() {} 
		console.log(lib.chainable());  // function() {}

		// Accessing privates from within functions works as expected
		Library.fn.doSomething = function() {
			console.log(this._abc); // 5
			console.log(this._func); // function() {}
			console.log(this.func1); // function() {}
			console.log(this.chainable().func1);  // function() {}
			console.log(this.chainable()._abc); // undefined
		}
		var lib2 = new Library();
		lib2.doSomething();
		// Show public properties
		console.log(lib2);

	</script>
	<body>
		_wm
	</body>
</html>